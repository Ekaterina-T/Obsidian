Утверждает,  что класс-родитель и его дети (в том числе дети между собой) должны быть взаимозаменяемы в коде.

Классы одного типа определяются тем, могут ли они без проблем заменить один другой.
Классический неочевидный пример с прямоугольником и квадратом. Нельзя заменить квадрат прямоугольником, оставив код прямоугольника без изменений (можем сломать квадрат поменяв только одну сторону).

Принцип относится к случаям работы с подмножествами/ подтипами.
Тесно связан с [[Interface Segregation Principle]]

## Ситуации

- не хочется указывать конкретный класс, с которым ведётся работа, т.к. метод может работать с несколькими подтипами; поэтому говорим у себя что ждём "родительский класс", а клиенты могут передавать его подтипы - все подтипы должны успешно отработать
- похоже на фабрику и на [[Open Closed Principle]]

## Вопросы

- есть ли абстракция с подтипами, с которыми хочется работать одинаково, не вникая с каким конкретным подтипом сейчас работаем?

## Признаки

- есть проверки типов и условная логика в классе-потребителе (т.е. клиент нашего класса вникает в то, с чем он работает)
- проверки на null (null может быть обёрнуть в UndefinedType с аналогичным интерфейсом)
- необработанные исключения (значит где-то подтипы невзаимозаменяемы)

#SOLID #LSP