Open for extension closed to modification

Код следует писать так, чтобы:
- его было легко расширять
- изменить код означало бы полную смену логики
- предпочитать не менять существующий код, а переиспользовать его в новом

То есть это принцип побуждает к конфигурированию настроек проекта, вместо жёстких связей с текущими настройками/ инструментами и т.д. и т.п. 

## Вопросы при разработке

1) **придётся ли менять код**:
	- если клиенту потребуется множество экземпляров сущностей, а не одна как сейчас 
		- 10 одинаковых фильтров, а не 1 как сейчас
	- если измениться поставщик данных для моего модуля 
		- другая база данных
	- изменится порядок в наборе выходных данных
		- переставить колонки, тайлы, и т.д.
	- потребуется поддержка нового аналогичного типа 
		-  сейчас нужно и умеем переводить на русский, но будет ещё английский
		- есть фильтр по числу, а будет и по тексту..
 2) насколько просто написать заглушки к тестам (уровень джедай: самому, а не через автоматическую систему)
3) какие входные данные могут меняться, даже гипотетически

## Достоинства

- снижается риск порчи работающих модулей
- снижается количество условных конструкций
- повышается читаемость (если наименования не совсем плохие)
- проще вносить изменения: конфигурация вместо изменений

## Примеры

- swicth cases - самый примитивный пример OCP, добавить поддержку нового типа очень просто
- наследование: введение абстрактного родителя и создание нового потомка при появлении 
- композиция: использовать базовый объект, как поле у нового класса/объекта
- паттерны: фабрика, декоратор



#SOLID #OCP