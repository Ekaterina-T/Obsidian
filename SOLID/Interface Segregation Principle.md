Открывать в интерфейсе минимально необходимый функционал.
Пример проверка типа подкласса [[Liskov Substitution Principle]]

Интерфейс класса должен быть небольшим.
Внутри модуля элементы должны быть сильно связаны - они решают одну задачу ([[Single Responsibility Principal]]). Модули, напротив, должны быть слабо связаны.

## Вопросы

- есть ли ситуация, что часть клиентов  пользуется одним подмножеством интерфейса, а другие клиенты другим? (разбить на 2 класса)
- есть ли ситуации, когда клиент что-то уточняет у нашего класса, чтобы принять решение как с ним работать? 
- есть ли заглушки, что "что-то не реализовано"
- есть ли очень большие интерфейсы?
- по классу точно понятно, где приватные методы, а где публичные?

#SOLID #ISP